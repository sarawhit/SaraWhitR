# Assignment 4

#### loading the library of tidyverse where the tidyverse package is stored to access
#### ggplot
library(tidyverse)
#### installing the package so one can reload it after every session
install.packages("tidyverse")
#### calling mpg dataframe A data frame is a rectangular collection of variables 
#### (in the columns) and observations (in the rows). mpg contains observations collected
#### by the US Environmental Protection Agency on 38 models of car.
mpg
#> # A tibble: 234 x 11
#>   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class 
#>   <chr>        <chr> <dbl> <int> <int> <chr>      <chr> <int> <int> <chr> <chr> 
#> 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…
#> 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…
#> 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…
#> 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…
#> 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…
#> 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…
#> # … with 228 more rows

#### mapping a gg scatterplot that maps car's engine size against fuel efficiency
#### shows a negative relationship between x and y variables 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

#creating a reusable template for making graphs with ggplot2
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))

#### mapping aesthetics in your plot to the variables in the dataset, maps class to 
#3## color aesthetic 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))

#### mapping class against size aesthetic 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
#### > Warning: Using size for a discrete variable is not advised.

#### mapping class to the alpha aesthetic, which controls the transparency of the points, 
#### or to the shape aesthetic, which controls the shape of the points
# Left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))

# Right
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))

#### setting aesthetic properties of geom manually, making all of the points blue
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")

#### missed parentheses so the point do not come out blue
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))

#### plus sign must come at the end of the line not the beginning
ggplot(data = mpg) 
+ geom_point(mapping = aes(x = displ, y = hwy))

#### facetting plot by a single variable. First argument is a formula, followed by ~
#### followed by variable name where formula is the name of a data structure in R/ The variable that 
#### is passed to facet_wrap should be discrete 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)

#### Facetting your plot on the combination of two variables, add facet_grid() to your 
#### plot call. The first argument of facet_grid() is also a formula. This time the 
#### formula should contain two variable names separated by a ~. The empty grids 
#### show that there is no data attributed to this specific variable 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)

#### Code creates 4 facet columns that are generated by the "." The data maps 
#### engine size against fuel efficiency
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)

#### facets columns and rows of each type of car variable, engine size against fuel 
#### efficiency 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)

#### point geom representation of the data
# left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

#### right smooth geom representation of the data
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))

#### drawing a different line, with a different linetype, for each unique value of
#### the variable that you map to linetype.
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))


#### geom smooth uses a single geometric object to display multiple rows of data.
#### Setting the group aesthetic to a categorical variable to draw multiple objects.
#### ggplot2 draws a separate object for each unique value of the grouping variable.
#### In practice, ggplot2 will automatically group the data for these geoms whenever you 
#### map an aesthetic to a discrete variable (linetype example)
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy))

ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))

ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE
  )

#### displaying multiple geoms in the same plot by adding multiple geom functions to
#### ggplot
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))

#### Avoiding duplication of variables by passing a set of mappings to ggplot()
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

#### Placing mappings in a geom function, ggplot2 treats them as local 
#### mappings for the layer. Uses these mappings to extend or overwrite the 
#### global mappings for that layer only. This makes it possible to display different 
#### aesthetics in different layers. 
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()

#### smooth line displays just a subset of the mpg dataset, the subcompact cars.
#### local data argument in geom_smooth() overrides the global data argument in 
#### ggplot() for that layer only.
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)

#### Point plot with smooth line mapping separated by color
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se = FALSE)

#### Same graph by avoiding duplication of variables by passing in the mapping function
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))

#### generates bar plot of the diamonds dataset showing that  more diamonds are 
#### available with high quality cuts than with low quality cuts
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))

#### Using geoms and stats interchangeably. You can
#### recreate the previous plot using stat_count() instead of geom_bar()
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))

#### Overriding the default stat. change the stat of geom_bar() from count 
#### (the default) to identity. Lets one map the height of the bars to the raw 
#### values of a y variable
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)

ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")

#### displaying a bar chart of proportion rather than count
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))

#### summarises the y values for each unique x value, to draw attention to 
#### the summary that you’re computing
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )

#### creates proportion bar chart that is color coordinated where proportion is = 1
#### because proportions cannot exceed 100% 
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = after_stat(prop)))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))

#### Coloring bars using function colour and fill 
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))

#### map the fill aesthetic to another variable, like clarity: the bars are 
#### automatically stacked. Each colored rectangle represents a combination of cut 
#### and clarity
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))

#### position = "identity" will place each object exactly where it falls in the 
#### context of the graph. Makes them transparent for easier viewing
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")

#### position = "fill" works like stacking, but makes each set of stacked bars the 
#### same height.
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")

#### position = "dodge" places overlapping objects directly beside one another.
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")

#### position = "jitter" adds a small amount of random noise to each point. This 
#### spreads the points out because no two points are likely to receive the same 
#### amount of random noise.
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")

#### point plot that does not include jittering to add random noise
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_point()

#### coord_flip() switches the x and y axes. This is useful (for example),
#### if you want horizontal boxplots
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot()
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot() +
  coord_flip()

#### coord_quickmap() sets the aspect ratio correctly for maps.
nz <- map_data("nz")

ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")

ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  coord_quickmap()

#### coord_polar() uses polar coordinates. Polar coordinates reveal an interesting 
#### connection between a bar chart and a Coxcomb chart
bar <- ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = cut, fill = cut), 
    show.legend = FALSE,
    width = 1
  ) + 
  theme(aspect.ratio = 1) +
  labs(x = NULL, y = NULL)

bar + coord_flip()
bar + coord_polar()

#### generates a regression line for the plot - shows that there is not a good 
#### relationship between the two variables. Creates a point plot without randomness
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_point() + 
  geom_abline() +
  coord_fixed()

#### adding add position adjustments, stats, coordinate systems, and faceting to our 
#### code template:

#ggplot(data = <DATA>) + 
#mapping = aes(<MAPPINGS>),
#stat = <STAT>, 
#position = <POSITION>
# ) +
#<COORDINATE_FUNCTION> +
#<FACET_FUNCTION>

library(tidyverse)
#### this line is loading the package 'tidyverse' which we already have installed

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(title = "Fuel efficiency generally decreases with engine size")
#### this section is making a scatterplot with the function geom_point and then 
#### making a line of best fit using the geom_smooth function
#### this section also employs the labs function to make the label for the title of the graph

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    title = "Fuel efficiency generally decreases with engine size",
    subtitle = "Two seaters (sports cars) are an exception because of their light weight",
    caption = "Data from fueleconomy.gov"
  )
#### Only difference from last section is that it uses the labs function to also add a subtitle and caption to the graph

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Engine displacement (L)",
    y = "Highway fuel economy (mpg)",
    colour = "Car type"
  )
#### Difference is that it uses x and y to define the axes labels and makes the legend label "car type"

df <- tibble(
  x = runif(10),
  y = runif(10)
)
ggplot(df, aes(x, y)) +
  geom_point() +
  labs(
    x = quote(sum(x[i] ^ 2, i == 1, n)),
    y = quote(alpha + beta + frac(delta, theta))
  )
#### this section is creating a data frame using the tibble function
#### it also uses mathematical functions in place of strings for the axes using the quote function

best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy)) == 1)

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_text(aes(label = model), data = best_in_class)
#### pulls out the highest rated of each class, in this case the most efficient cars

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_label(aes(label = model), data = best_in_class, nudge_y = 2, alpha = 0.5)
#### this section uses the geom_label function to draw a rectangle behind the text, with nudge_y moving the labels above the corresponding points

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_point(size = 3, shape = 1, data = best_in_class) +
  ggrepel::geom_label_repel(aes(label = model), data = best_in_class)
#### Using the ggrepel package to automatically adjust labels so they don't overlap

class_avg <- mpg %>%
  group_by(class) %>%
  summarise(
    displ = median(displ),
    hwy = median(hwy)
  )


ggplot(mpg, aes(displ, hwy, colour = class)) +
  ggrepel::geom_label_repel(aes(label = class),
                            data = class_avg,
                            size = 6,
                            label.size = 0,
                            segment.color = NA
  ) +
  geom_point() +
  theme(legend.position = "none")
#### replacing the legend with labels on the plot

label <- mpg %>%
  summarise(
    displ = max(displ),
    hwy = max(hwy),
    label = "Increasing engine size is \nrelated to decreasing fuel economy."
  )

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_text(aes(label = label), data = label, vjust = "top", hjust = "right")
#### this section adds a single label to the plot by creating a new data frame

label <- tibble(
  displ = Inf,
  hwy = Inf,
  label = "Increasing engine size is \nrelated to decreasing fuel economy."
)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_text(aes(label = label), data = label, vjust = "top", hjust = "right")
#this section places the text we just created directly on the borders of the plot

"Increasing engine size is related to decreasing fuel economy." %>%
  stringr::str_wrap(width = 40) %>%
  writeLines()
"Increasing engine size is related to
decreasing fuel economy."
#### this section adds line breaks given the number of characters

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_colour_discrete()
#### this section chooses scales that are not the default

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5))
#### this section uses the break function to override the default choice of axes ticks

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL)
#### this section uses labels = NULL to get rid of the numeric tick labels on the axes

presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id)) +
  geom_point() +
  geom_segment(aes(xend = end, yend = id)) +
  scale_x_date(NULL, breaks = presidential$start, date_labels = "'%y")
#### this section uses the breaks function to highlight the observations in the data set

base <- ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))

base + theme(legend.position = "left")
base + theme(legend.position = "top")
base + theme(legend.position = "bottom")
base + theme(legend.position = "right") # the default
#### controlling where the legend is drawn

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  theme(legend.position = "bottom") +
  guides(colour = guide_legend(nrow = 1, override.aes = list(size = 4)))
#`geom_smooth()` using method = 'loess' and formula 'y ~ x'
#### uses nrow to control the number of rows and overrides the aesthetic using override.aes

ggplot(diamonds, aes(carat, price)) +
  geom_bin2d()

ggplot(diamonds, aes(log10(carat), log10(price))) +
  geom_bin2d()
#### log transforms the data to make it easier to see the precise relationship

ggplot(diamonds, aes(carat, price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()
#### we use this to get rid of the log axes labels and rescale the axes

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv))

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv)) +
  scale_colour_brewer(palette = "Set1")
#### adjusts the colors of the graph using the palette function

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_colour_brewer(palette = "Set1")
#### adds a shape mapping using the shape function

presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id, colour = party)) +
  geom_point() +
  geom_segment(aes(xend = end, yend = id)) +
  scale_colour_manual(values = c(Republican = "red", Democratic = "blue"))
#### this section sets the colors of the data set to match the standard mapping of party with colour = party

df <- tibble(
  x = rnorm(10000),
  y = rnorm(10000)
)
ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed()

ggplot(df, aes(x, y)) +
  geom_hex() +
  viridis::scale_fill_viridis() +
  coord_fixed()
#### employs a colour scheme that uses continous colors

ggplot(mpg, mapping = aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth() +
  coord_cartesian(xlim = c(5, 7), ylim = c(10, 30))

mpg %>%
  filter(displ >= 5, displ <= 7, hwy >= 10, hwy <= 30) %>%
  ggplot(aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth()
#### this section uses coord_cartesian to zoom in on a specific region of the plot

suv <- mpg %>% filter(class == "suv")
compact <- mpg %>% filter(class == "compact")

ggplot(suv, aes(displ, hwy, colour = drv)) +
  geom_point()

ggplot(compact, aes(displ, hwy, colour = drv)) +
  geom_point()
#### this section subsets the data

x_scale <- scale_x_continuous(limits = range(mpg$displ))
y_scale <- scale_y_continuous(limits = range(mpg$hwy))
col_scale <- scale_colour_discrete(limits = unique(mpg$drv))

ggplot(suv, aes(displ, hwy, colour = drv)) +
  geom_point() +
  x_scale +
  y_scale +
  col_scale

ggplot(compact, aes(displ, hwy, colour = drv)) +
  geom_point() +
  x_scale +
  y_scale +
  col_scale
#### shares the scales of the plots across different plots using the limits function

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()
#### uses theme_bw to change the theme of the blot

ggplot(mpg, aes(displ, hwy)) + geom_point()
#### creates a ggplot as we have been doing

ggsave("my-plot.pdf")

#Saving 7 x 4.33 in image
#### uses the ggsave function to save our current plot as an image





